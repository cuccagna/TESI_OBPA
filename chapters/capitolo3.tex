%!TEX encoding = UTF-8 Unicode
%!TEX root = ./../main.tex
%!TEX TS-program = xelatex

\chapter[Algoritmi d'apprendimento]{Algoritmi di apprendimento} % Main chapter title
\label{cap:tre}
\section{Active Learning}
L' \textit{Active Learning} è un caso speciale di \textit{semi-supervisionato machine learning}\footnote{Nel semi-supervisionato learning una piccola quantità di dati è etichettata e la restante, la maggioranza, è senza etichetta.} in cui un algoritmo di \textit{learning} può interagire con l'utente o  qualche sorgente d'informazione per ottenere informazioni significative come ad esempio l'etichetta di un'istanza. Nel contesto dell' \ac{IIR} l' \textit{active learning} non esplora il reticolo costruito a partire dal PTA o dall' APTA come fanno gli algoritmi presentati in [METTI RIFERIMENTO RPNI EDSM]   ma si basa su una stretta interazione tra il \textit{learner} e il \textit{\textbf{teacher}} talvolta detto \textit{\textbf{Oracolo}} o \textit{\textbf{informant}}. Non vi è più l'esplorazione dello spazio di ricerca creato a partire dal nodo iniziale (PTA o APTA) costruito a sua volta dagli esempi iniziali ma è il \textit{learner} che sceglie gli esempi e inoltre  il \textit{teacher} può selezionare attentamente i controesempi significativi: proprio per queste ragioni spesso il numero di esempi per apprendere un concetto e in generale il tempo di esecuzione del processo di apprendimento è minore nell' \textit{active learning} rispetto agli approcci basati sull'esplorazione del reticolo.
L'\textit{active learning} nasce per ragioni teoriche come ad esempio per dimostrare che non è possibile apprendere in maniera efficiente alcune classi di linguaggi con algoritmi given-data in cui gli esempi sono imposti: è sufficiente dimostrare che il numero di query non può essere polinomiale nell' \textit{active learning} (nel cui contesto si può scegliere quali esempi vedere). Ma è anche applicabile in numerosi contesti pratici come la Robotica in cui un agente può costruire una mappa usando l'interazione tra i sensori e l'ambiente come \textit{Oracolo} o nella modellazione dell'acquisizione dei linguaggi naturali dove attribuire la figura del \textit{teacher} al genitore risulta naturale. Qui si esaminerà l' \textit{active learning} nell' \ac{IIR}. L* è senz altro il più noto algoritmo in letteratura di \textit{active learning} applicato ai linguaggi regolari. Il più recente e performante \ac{ObP} sarà introdotto nel capitolo \ref{cap:quattro}
\subsection{Active learning nell' Inferenza Induttiva Regolare}
Il paradigma dell' \textit{active learning} si basa sull'esistenza di un \textit{Oracolo} che conosce \ac{L} e può rispondere solo a certi tipi di interrogativi del \textit{learner}. L' \textit{Oracolo} può trovarsi in una situazione in cui più risposte valide sono possibili e in questo caso si deve assumere che non viene rispettata nessuna distribuzione di probabilità nelle risposte date ma che queste sono casuali pertanto nell'analisi dell'algoritmo si deve assumere il caso peggiore cioè un \textit{Oracolo} avverso (nell' algoritmo adoperato nell' \ac{IIR}, il table-filling descritto nella sottosezione \ref{sub:tea}, l'\textit{Oracolo} non garantisce di ritornare la \textit{\textbf{witness}} cioè il controesempio più breve).
I principali tipi di interrogativi possibili a cui si può sottoporre un \textit{Oracolo} sono:
\begin{itemize}
\item \textbf{\ac{MQ}} Una membership query è effettuata proponendo una stringa all'\textit{Oracolo}, che risponde YES se la stringa appartiene a \ac{L} e NO se la stringa non appartiene:\\\\
\centerline{$\text{\ac{MQ}} : \Sigma^{*}  \to \text{\{YES,NO\}}$}

\item \textbf{\ac{EQ}} (forte) Un'equivalence query (forte) è effettuata proponendo un DFA ipotesi all'\textit{Oracolo} che risponde YES se il DFA ipotesi è equivalente al DFA target altrimenti ritorna una stringa(\textit{witness}) appartenente alla differenza simmetrica tra \ac{L} e $\mathcal{L}$(DFA):\\\\
\centerline{\ac{EQ} : \textit{DFA}$ \to \text{\{YES\}} \cup \Sigma^{*}$}

\item \textit{\textbf{WEQ}} (debole) Un'equivalence query (debole) è effettuata proponendo un DFA ipotesi all'\textit{Oracolo} che risponde YES se il DFA ipotesi è equivalente al DFA target altrimenti ritorna NO :\\\\
\centerline{\textit{WEQ} : \textit{DFA}$ \to  \text{\{YES,NO\}}$}

\item \textit{\textbf{SSQ}} Una subset query è effettuata proponendo un DFA all'\textit{Oracolo} che risponde YES se \ac{L}(DFA) è un sottoinsieme di \ac{L} altrimenti ritorna una stringa appartenente a \ac{L}(DFA) che non appartiene ad \ac{L} :\\\\
\centerline{\textit{SSQ} : \textit{DFA}$ \to \text{\{YES\}} \cup \Sigma^{*}$}
\end{itemize}



I seguenti risultati e definizioni sono in \cite{Angluin90}.Si da la seguente definizione preliminare:
\begin{definizione}
Chiamiamo $\rho$ un'esecuzione del \textit{learner} A. Chiamiamo $\Braket{r_1,r_2,\dots r_m}$ la sequenza di risposta alle query $\Braket{q_1,q_2,\dots q_m}$ che l'\textit{Oracolo} fa durante l'esecuzione $\rho$ . Si dice che \textbf{A} è \textbf{polinomialmente  limitato} se esiste un polinomio a due variabili p() che dato qualsiasi formalismo L descrivente  \ac{L} e in qualsiasi esecuzione $\rho$, e a qualsiasi \textit{query point}(indica il momento in cui avviene una specifica query) $k$ dell'esecuzione, denotando il tempo di esecuzione prima di quel punto con $t_k$, si ha:
\begin{itemize}
\item $k \le p(\norma{L} , \text{max}\{\abs{r_i} : i \textless k \})$
\item $\abs{q_k} \le p(\norma{L} , \text{max}\{\abs{r_i} : i \textless k \})$
\item $t_k \in \mathcal{O}(p(\norma{L} , \text{max}\{\abs{r_i} : i \textless k \}))$
\end{itemize}
\end{definizione}
Informalmente significa che in qualsiasi \textit{query point k} di qualunque esecuzione, al momento precedente l'effettuazione della query $q_k$, si ha che il numero di query fatte, il tempo di esecuzione e la dimensione della prossima query ($q_k$) sono tutte limitate da un polinomio $p$ dipendente dalla dimensione del target e dalla lunghezza del più lungo controesempio ritornato dall'\textit{Oracolo} fino a quel punto
   
La seguente definizione stabilisce quando una classe di linguaggi è efficientemente identificabile \textit{in the limit} da un algoritmo di  \textit{learning}. 
\begin{definizione}
\label{def:pol}
Una classe di linguaggi $\mathfrak{L}$ è \textbf{polinomialmente \textit{identificabile in the limit con query}} fissati i tipi di query possibili se esiste un \textbf{polinomialmente limitato} \textit{learner} \textbf{A} che dato il formalismo descrivente qualsiasi linguaggio L in  $\mathfrak{L}$, identifica L in the limit, cioè ritorna  L' equivalente ad L e termina.
\end{definizione}

Adesso ci si chiede se la classe dei linguaggi regolari è polinomialmente identificabile in the limit tramite qualche algoritmo di apprendimento secondo la definizione \ref{def:pol}. E' importante sottolineare che la risposta a questa domanda dipende anche dalla classe cui appartiene l'\textit{Oracolo} cioè dal tipo di interrogativi che è possibile rivolgergli.  A tal proposito si hanno i seguenti risultati :
\begin{teorema}
\label{teo:noi}
La classe dei linguaggi regolari  non è polinomialmente identificabile in the limit da un numero polinomiale di \ac{MQ}, \textit{WEQ} e \textit{SSQ}
\end{teorema}
Quindi come conseguenza del teorema \ref{teo:noi}   la classe dei linguaggi regolari non è polinomialmente identificabile in the limit  neanche sottoponendo all'\textit{Oracolo} esclusivamente \ac{MQ} .

Un'ulteriore risultato è il seguente: 
\begin{teorema}
\label{teo:noe}
La classe dei linguaggi regolari: \textit{DFA}  non è polinomialmente identificabile in the limit da un numero polinomiale di \ac{EQ} (forti)
\end{teorema}
Si rimanda alla sezione \ref{sec:lstar} per le condizioni di polinomiale identificabilità in the limit dei linguaggi regolari
\section{L*}
\label{sec:lstar}
L* è il più noto algoritmo di \textit{active learning} nell'ambito dell' \ac{IIR} e garantisce di emettere in output il DFA minimo ( o uno ad esso isomorfo ) accettante \ac{L}. Detto n il numero degli stati del DFA target minimo ed m la lunghezza del più lungo controesempio ritornato dall' \textit{Oracolo} durante l'inferenza, il costo computazionale di L* sarà limitato da una funzione polinomiale di n ed m. In L* il \textit{teacher} appartiene alla classe dei \ac{MAT} in grado di rispondere ad \ac{EQ} e \ac{MQ}. Questi risultati ,che consentono di dire che i linguaggi regolari sono polinomialmente identificabili in the limit (definizione \ref{def:pol}),  sono stati conseguiti da Dana Angluin \cite{Angluin87} e succintamente riportati nel seguente teorema:
\begin{teorema}
Dato un \ac{MAT}  presentante un linguaggio regolare sconosciuto U, il Learner L* termina restituendo in output un automa finito isomorfo al DFA minimo accettante  il linguaggio target U. Inoltre, se n è il numero di stati del DFA minimo accettante U e  m è un limite superiore della lunghezza di ogni controesempio ritornato dal Teacher, allora il costo totale di esecuzione di L* è limitato da un polinomio in n ed m 
\end{teorema}

L* viene presentato all'interno del \textit{red--blue framework} [INSERISCI RIFERIMENTO] che in algoritmi come \textit{EDSM} [INSERISCI RIFERIMENTO] consente di diminuire i \textit{merges}. In L* l'adozione di questo \textit{framework} malgrado non comporti un vantaggio computazionale consente un'esposizione più chiara.  
\subsection{Tabella di Osservazione}
\label{sub:obt}
Una \textbf{tabella di osservazione} è una struttura dati che rappresenta il DFA ipotesi congetturato al passo corrente. Al suo interno sono codificati gli esiti delle \ac{MQ} richieste al \textit{teacher}.

\begin{definizione*}[Tabella di Osservazione] La \textit{tabella di osservazione} è una tripla $\Braket{STA, EXP, OT}$, dove:
\begin{itemize}
\item $\text{STA}=\text{RED} \cup \text{BLUE}$.  STA è un insieme finito di stringhe definite su $\Sigma$ che rappresentano gli stati. STA è \textbf{prefix--closed}\\
RED $\in \Sigma^{*}$ è un insieme finito di stati\\
$\text{BLUE} = \{ua \notin \text{RED} : u \in \text{RED}\}$ è l'insieme dei successori degli stati RED che non sono RED. Rappresentano le transizioni.
\item EXP $\in \Sigma^{*}$  è l'insieme degli esperimenti. E' \textbf{suffix--closed}
\item $\text{OT} : \text{STA} \times \text{EXP} \to \text{\{0,1,*\}}$ è una funziona così definita:\\\\
\centerline{$
OT[u][e] = 
\begin{cases}
1
& \text{se $ue \in \ac{L}$} \\
0 & \text{se $ue \notin \ac{L}$}\\
* & \text{altrimenti}
\end{cases}
$}   
\end{itemize}
\end{definizione*} 
Dalla tabella di osservazione si costruisce una nuova ipotesi e la si sottopone al'\textit{teacher}. Se l'ipotesi non è equivalente al \textit{DFA target} il \textit{teacher} torna un controesempio che sarà usato dal \textit{learner} per \textit{splittare} gli stati e modificare la tabella di osservazione per ottenere una nuova ipotesi cofacente al controesempio. Le \ac{MQ} permettono di riempire i buchi generati dall'introduzione di nuovi prefissi dal controesempio.  A partire dalla tabella di osservazione è possibile costruire un DFA ipotesi sole se questa gode di tre proprietà:\\

{\large\textbf{Completezza}}

La completezza garantisce che non ci siano comportamenti parzialmente (o totalmente) sconosciuti per prefissi presenti all'interno della tabella.
\begin{definizione*}[Tabella completa] Una tabella è completa se non ha \textit{buchi}. Un \textit{buco} in una tabella di osservazione è una coppia (u,e) tale che $OT[u][e] = *$.
\end{definizione*}
L'eventuale incompletezza può essere eliminata mediante \ac{MQ} al \textit{teacher}.\\

{\large\textbf{Chiusura}}

La chiusura (algoritmo \ref{alg:lstar-close}) assicura che ogni possibile stato raggiunto con una transizione sia presente tra gli stati finali dell'automa. Dato un elemento $s \in$ STA e gli \textit{n} esperimenti $e \in $ EXP si indica con row(s) la riga in OT indicizzata da s cioè $row(s)=OT[s][e_1] \cdot OT[s][e_2] \cdot \dots OT[s][e_n]$ . Gli stati dell'automa sono un sottoinsieme degli stati RED, quando una transizione da uno stato RED porta ad uno stato BLUE  si deve trovare uno stato RED equivalente a quello BLUE (vedasi algoritmo \ref{alg:lstar-buildautomaton}) (almeno secondo i suffissi trovati fino a quel momento) in modo che la transizione arrivi in questo stato (che è presente nell'automa ipotesi perchè è uno stato RED a differenza di quello BLUE)
\begin{definizione*}[Tabella chiusa] Una tabella è \textbf{chiusa} se $\forall u \in \text{BLUE}, \exists s\\ \in \text{RED} : \text{row(u)} = \text{row(s)}$
\end{definizione*}
Se la tabella di osservazione non fosse chiusa è possibile renderla tale mediante una (o più) \textbf{promozione}, cioè l'inserimento di \textbf{u} nei RED e $u \cdot \Sigma$ nei BLUE\\

{\large\textbf{Consistenza}}

La consistenza  (algoritmo \ref{alg:lstar-consistent}) impedisce situazioni di indeterminismo nel DFA, nella fattispecie che da uno stato dell'ipotesi per uno stesso simbolo dell'alfabeto si giunga in stati di arrivo diversi. Questa situazione è resa possibile dal fatto che l'algoritmo non impedisce di avere due stati RED $s_1$ ed $s_2$ tali che $\text{row}(s_1) = \text{row}(s_2)$ . 
\begin{definizione*}[Tabella consistente]Una tabella di osservazione è \textbf{consistente} se $\forall s_1,s_2 \in \text{RED} : \text{row}(s_1)=\text{row}(s_2)\implies\forall a \in \Sigma,\text{row}(s_1a)=\text{row}(s_2a)$
\end{definizione*} 

La definizione sopra significa che affinchè vi sia consistenza ogni coppia di stati equivalenti RED cioè di stati in RED con righe uguali deve restare equivalente in STA aggiungendo qualsiasi simbolo dell'alfabeto. 
Se la tabella di osservazione non fosse consistente è possibile renderla tale ampliando l'insieme EXP con la stringa composta dal suffisso e dall'esperimento che hanno generato l'inconsistenza. Ciò assicura che i due stati $s_1$ ed $s_2$ che prima erano equivalenti (e che quindi rappresentavano un unico stato nell'ipotesi) adesso non lo sono più perchè  $\text{row}(s_1) \neq \text{row}(s_2)$ e quindi sarà aggiunto un nuovo stato all'insieme RED cioè un nuovo stato all'ipotesi.

\begin{algorithm}
\caption{LSTAR-BUILDAUTOMATON}\label{alg:lstar-buildautomaton}
\begin{algorithmic}[1]
\Statex
\Input a closed and complete observation table $\Braket{\text{STA,EXP,OT}}$
\Output DFA $\Braket{\Sigma,Q,q_\epsilon,F_A,F_R,\delta}$
\State $Q \gets \{q_u : u \in \text{RED} \land \forall v < u \: \text{row}(v) \ne \text{row}(u)\}$
\LineComment{le stringhe più corte sono minori e per stringhe della stessa lunghezza si intendono minori quelle che lessicograficamente vengono prima}
\State $F_{\mathbb{A}} \gets \{q_u \in Q : \text{OT}[u][\epsilon] = 1\}$
\State $F_{\mathbb{R}} \gets \{q_u \in Q : \text{OT}[u][\epsilon] = 0\}$
\For{$q_u \in Q$}
     \For{$a \in \Sigma$} $\delta(q_u,a) \gets q_w \in Q : \text{row}(ua) = \text{row}(w)$
     \EndFor
\EndFor
\State \textbf{end for}
\State \Return{$\Braket{\Sigma,Q,q_\epsilon,F_A,F_R,\delta}$}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{LSTAR}\label{alg:lstar}
\begin{algorithmic}[1]
\Statex
\Input --
\Output DFA $\mathcal{A}$
\State \Call{LSTAR-INITIALISE}{}
\Repeat
     \While{$\Braket{\text{STA,EXP,OT}} \textit{is not closed or not consistent}$}
          \If{$\Braket{\text{STA,EXP,OT}} \textit{is not closed}$}
          \vspace{0.5mm}
               \State $\Braket{\text{STA,EXP,OT}} \gets \Call{LSTAR-CLOSE}{\Braket{\text{STA,EXP,OT}}} $
          \EndIf
          \If{$\Braket{\text{STA,EXP,OT}} \textit{is not consistent}$}
          \vspace{0.5mm}
               \State $\Braket{\text{STA,EXP,OT}} \gets \Call{LSTAR-CONSISTENT}{\Braket{\text{STA,EXP,OT}}} $ 
          \EndIf    
     \EndWhile
     \State \textbf{end while}
     \State $\text{Answer} \gets \Call{EQ}{\Braket{\text{STA,EXP,OT}}}$
     \If{$\text{Answer} \ne \text{YES}$}
          \vspace{0.25mm}
          \State $\Braket{\text{STA,EXP,OT}} \gets \Call{LSTAR-USEEQ}{\Braket{\text{STA,EXP,OT}},\text{Answer}}$
     \EndIf
\Until{$\text{Answer} = \text{YES}$}
\State \textbf{return} \Call{LSTAR-BUILDAUTOMATON}{$\Braket{\text{STA,EXP,OT}}$}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{LSTAR-INITIALISE}\label{alg:lstar-initialise}
\begin{algorithmic}[1]
\Statex
\Input --
\Output $\Braket{\text{STA,EXP,OT}}$
\State $\text{RED} \gets \{q_\epsilon\}$
\State $\text{BLUE} \gets \{q_a : a \in \Sigma\}$
\State $\text{EXP} \gets \{\epsilon\}$
\State $\text{OT}[\epsilon][\epsilon] \gets \Call{MQ}{\epsilon}$
\vspace{1mm}
\For{$a \in \Sigma$} $\text{OT}[a][\epsilon] \gets \Call{MQ}{a}$
\EndFor
\State \textbf{return} $\Braket{\text{STA,EXP,OT}}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{LSTAR-CLOSE}\label{alg:lstar-close}
\begin{algorithmic}[1]
\Statex
\Input $\Braket{\text{STA,EXP,OT}}$
\Output $\Braket{\text{STA,EXP,OT}}$ updated
\For{$s \in \text{BLUE} \: \textit{such that} \: \forall u \in \text{RED} \: \text{row}(s) \ne \text{row}(u)$}
\LineComment{Non per $\forall s$ ma per uno solo quindi la tabella in output può ancora essere non chiusa}
     \State $\text{RED} \gets \text{RED} \cup \{s\}$
     \State $\text{BLUE} \gets \text{BLUE} \: \setminus \: \{s\}$
     \For{$a \in \Sigma$} BLUE $\gets \text{BLUE} \cup \{s\cdot a\}$
     \EndFor
     \For{$u, e \in \Sigma^{*}  \: \textit{such that} \: \text{OT}[u][e] \textit{is a hole}$} $\text{OT}[u][e] \gets \Call{MQ}{ue}$
\EndFor
\EndFor
\State \textbf{end for}
\State \textbf{return} $\Braket{\text{STA,EXP,OT}}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{LSTAR-CONSISTENT}\label{alg:lstar-consistent}
\begin{algorithmic}[1]
\Statex
\Input $\Braket{\text{STA,EXP,OT}}$
\Output $\Braket{\text{STA,EXP,OT}}$ updated
\State find $s_1, s_2 \in$ RED, $a \in \Sigma$ and $e \in$ EXP \textit{such that} row$(s_1) = \text{row}(s_2)$ and
\State $\text{OT}[s_1 \cdot a][e] \ne \text{OT}[s_2 \cdot a][e]$
\LineComment{se $s_1a \: \text{ed} \: s_2a$ differiscono per più di un esperimento basta considerarne uno}
\State $\text{EXP} \gets \text{EXP} \cup \{a \cdot e\}$ 
\For{$u, e \in \Sigma^{*}  \: \textit{such that} \: \text{OT}[u][e] \textit{is a hole}$} $\text{OT}[u][e] \gets \Call{MQ}{ue}$
\EndFor
\State \textbf{return} $\Braket{\text{STA,EXP,OT}}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{LSTAR-USEEQ}\label{alg:lstar-useeq}
\begin{algorithmic}[1]
\Statex
\Input $\Braket{\text{STA,EXP,OT}}$
\Output $\Braket{\text{STA,EXP,OT}}$ updated
\For{$p \in \text{PREF(Answer)}$}
\Comment{Anche Answer fa parte dei prefissi}
     \State $\text{RED} \gets \text{RED} \cup \{p\}$
\Comment{Se un pref. è già in OT renderlo RED se non lo è}
     \For{$a \in \Sigma : pa \notin \text{PREF(Answer)}$} $\text{BLUE} \gets \text{BLUE} \cup \{pa\}$ 
     \EndFor 
\EndFor
\State \textbf{end for}
\For{$u, e \in \Sigma^{*}  \: \textit{such that} \: \text{OT}[u][e] \textit{is a hole}$} $\text{OT}[u][e] \gets \Call{MQ}{ue}$
\EndFor
\State \textbf{return} $\Braket{\text{STA,EXP,OT}}$
\end{algorithmic}
\end{algorithm}

\subsection{L'algoritmo}
\subsubsection{Funzionamento}La \textit{ratio} che ispira L* é il teorema \textit{Myhill-Nerode} (sezione \ref{teo:m-n}). Nella tabella di osservazione le righe RED,in realtà un sottoinsieme delle stringhe RED, corrispondono agli stati del DFA ipotesi e le colonne, l'insieme EXP, corrispondono alle stringhe rappresentanti i suffissi che distinguono coppie di stati distinti dell'ipotesi. I singoli stati sono etichettati dalle stringhe che portano dallo stato iniziale allo stato stesso. Lo stato iniziale è etichettato dalla stringa $\epsilon$. Per ogni stato l'etichetta della colonna (un esperimento) indica lo stato che potrebbe essere raggiunto dallo stato dopo la lettura della stringa corrispondente all'etichetta dell'esperimento. Due stati sono considerati equivalenti se hanno le righe uguali nella tabella.

L'algoritmo inizia costruendo una tabella di osservazione corrispondente all'automa universale (algoritmo \ref{alg:lstar-initialise})
Una volta resa la tabella completa,chiusa e consistente viene estratta l'ipotesi corrispondente e viene effettuta un'\ac{EQ} dell'ipotesi al \textit{teacher}. In caso di risposta affermativa cioè di equivalenza il processo termina in quanto il \textit{learner} ha identificato un automa uguale o equivalente al \textit{target} (L* inferisce il DFA minimo, invece il \textit{target} potrebbe non essere un DFA minimo). In caso contrario sarà ritornato un controesempio che sarà usato per modificare la tabella di osservazione e quindi formulare una nuova ipotesi. L'algoritmo \ref{alg:lstar} chiarifica e approfondisce i passaggi summenzionati.

\subsubsection{Correttezza}
\label{sub:cor}
Per verificare che L* è corretto è sufficiente dimostare che termina dato che la terminazione con un  \ac{MAT} assicura l'equivalenza dell'ipotesi col target.
A tal fine si riporta preliminarmente il seguente teorema (\cite{Angluin87}):
\begin{teorema}
\label{teo:angm}
Se una tabella di osservazione è completa,chiusa e consistente, allora l'ipotesi \ac{H} (quella inferita dall'algoritmo \ref{alg:lstar-buildautomaton}) è consistente con la funzione OT. Qualsiasi altra ipotesi consistente con OT ma non equivalente ad \ac{H} deve avere più stati.
\end{teorema}
Nel teorema \ref{teo:angm} con ipotesi consistente con la funzione OT si intende che $\forall u \in \text{STA e } \forall e \in \text{EXP},  ue \in \ac{L} \iff \text{OT}[u][e] = 1$

Il risultato del teorema \ref{teo:angm} è che qualunque DFA consistente con OT o è isomorfico all'ipotesi inferita da L* o contiene almeno uno o più stati. Quindi ogni ipotesi \ac{H} fatta da L* è sempre il minimo DFA consistente con OT.

Un altro risultato che ci torna utile è:
\begin{lemma}
\label{lem:fgv}
Detto n il numero di differenti valori di $row(s) \text{ per } \forall \text{ s } \in \text{RED}$ in una tabella di osservazione. Qualsiasi \ac{H} consistente con OT deve avere almeno n stati
\end{lemma}
Si indica con n il numero di stati del DFA minimo di \ac{L}. E' facile dimostrare che il numero di valori distinti di $row(s) \text{per} s \text{in RED} $ è incrementato monotonicamente fino ad un massimo di n durante l'esecuzione di L*. Infatti sia la chiusura che la consistenza introducono un nuovo stato RED. Se la tabella fosse già chiusa e consistente il controesempio $t$ tornato dal \textit{teacher} comunque garantisce che un nuovo stato RED venga aggiunto alla tabella di osservazione: se $T_u$ è il DFA \textit{target} minimo (ovviamente consistente con OT) e il controesempio $t$ ci permette di dedurre che \ac{H} e  $T_u$  non sono equivalenti dal teorema \ref{teo:angm} sappiamo che \ac{H} ha al massimo $n-1$ stati. Inoltre L* classificherà il controesempio $t$ allo stesso modo di $T_u$ e quindi il nuovo DFA ipotesi che otterrà \textit{H'} sarà non equivalente con \ac{H} (per via di t) e inoltre sarà consistente con OT, quindi dal teorema \ref{teo:angm}  si deduce che \textit{H'} deve avere almeno n stati (almeno 1 stato in più di \ac{H}).

Questo dimostra che ad ogni passo del ciclo più esterno di L* almeno uno stato RED distinto deve essere aggiunto sempre alla tabella di osservazione. Quando ci saranno n stati RED distinti L* troverà il DFA \textit{target} minimo consistente con OT infatti il DFA \textit{target} minimo è sempre consistente con OT\footnote{Ma se sia il \textit{target} che \ac{H} sono sempre consistenti con OT come si fa a trovare un controesempio? La risposta è semplice: da OT viene creata un' ipotesi \ac{H} consistente all'OT ma nell'ipotesi possono essere \textit{parsate} anche altre stringhe non contemplate in OT da cui può derivare la non equivalenza con il \textit{target}} e l'ipotesi creata da L* è sempre il DFA minimo per il teorema \ref{teo:angm} e dal lemma \ref{lem:fgv} si ha che l'ipotesi creata da L* deve avere almeno n stati.
Essendo il DFA ipotesi un DFA ipotesi minimo e con n stati e consistente con T non può essere che uguale o isomorfo col DFA \textit{target minimo}.  Quindi L* dovrà costruire nel caso peggiore $n-1$ ipotesi errate prima di trovare l'ipotesi corretta e quindi il numero di \ac{EQ} è al massimo n (perchè l'ipotesi corretta comunque va sottoposta al \textit{teacher})

\subsubsection{Complessità computazionale}Come detto in precedenza la complessità computazionale di L* è limitata da un polinomio dipendente dal numero di stati del DFA minimo identificante \ac{L} e dalla lunghezza del controesempio più lungo ritornato dal \textit{teacher}.In \cite{Angluin87} si trova una dimostrazione dettagliata di quanto detto sopra. In questa sede si analizzano dei parametri oggettivi nella valutazione del costo computazionale cioè il numero di \ac{MQ} e di \ac{EQ}. In quest'analisi si terrà conto anche di k un ulteriore parametro che rappresenta la dimensione dell'alfabeto. Il numero di \ac{EQ} sarà limitato da n (sottosezione correttezza \ref{sub:cor}) come dimostrato in precedenza. Il numero di \ac{MQ} è invece limitato dalla dimensione della tabella di osservazione. Il numero di elementi in EXP non può eccedere n , in quanto l'insieme EXP viene incrementato di un elemento quando la tabella di osservazione è inconsistente (algoritmo \ref{alg:lstar-consistent}) e l'inconsistenza può presentarsi al più $n-1$ volte perchè ogni volta viene aggiunto un nuovo nodo RED distinto (con n nodi RED distinti L* termina) (la dimensione di EXP è al più n e non $n-1$ perchè EXP inizialmente contiene $\lambda$).EXP rappresenta il numero di colonne della tabella di osservazione, adesso si calcola il numero di righe della stessa. Il numero di stati RED non può eccedere $n+m(n-1)$  perchè gli stati RED sono aggiunti quando si scopre che la tabella non è chiusa e quando il \textit{teacher} torna un controesempio.  La non chiusura può accadere al più $n-1$ volte ed ogni volta aggiunge uno stato RED, e ci possono essere massimo $n-1$ controesempi ognuno dei quali può causare l'aggiunta di al più $m$ stati RED (numero dei prefissi se il controesempio è lungo $m$). Il numero degli stati BLUE è al più $k(n+m(n-1))$ perchè i BLUE sono ottenuti concatenando tutti i simboli dell'alfabeto agli stati RED. Quindi la dimensione della tabella sarà $\text{righe} * \text{colonne}$ cioè $\text{(RED}+\text{BLUE)}*\text{EXP}$ quindi si ha:
\begin{equation*}
(k+1)(n+m(n-1))\,n = \mathcal{O}(kmn^{2})
\end{equation*}
che è il numero di \ac{MQ} totali.
\subsection{Il teacher} 
\label{sub:tea}Il teacher di L* essendo un \ac{MAT} è chiamato a rispondere a due tipi di query: \ac{MQ} ed \ac{EQ}. Si suppone che esso abbia a disposizione il DFA che identifica \ac{L} quindi è immediato rispondere a una \ac{MQ}. Il \textit{teacher} deve anche vagliare l'equivalenza del target con l'ipotesi fornitagli dal \textit{learner} e in caso di inequivalenza deve tornare un controesempio. A tal fine il \textit{table-filling algorithm} \cite{Nor09} risulta essere un buon algoritmo (il più performante con complessità quasi lineare atto solo a testare l'equivalenza e tornare una witness  quindi senza consentire anche la minimizzazione è \cite{Hop71} )
\subsubsection{Table-filling}Il \textit{table-filliling} \cite{Nor09} è un algoritmo in grado di individuare ricorsivamente tutti gli stati tra loro distinti, alla fine dell'esecuzione le coppie di stati non marcati come tali saranno coppie di stati equivalenti. Per questo motivo l'algoritmo di table-filling è utilizzato anche nella minimizzazione di DFA dove gli stati trovati equivalenti saranno fusi in un unico stato.

Per stati distinti si intende stati per cui esiste almeno una stringa che partendo da quei due stati (e non dallo stato iniziale) giunge in una coppia di stati di arrivo composta da uno stato accettante e da uno stato rigettante.

Inizialmente si distinguono le coppie di stati che non sono equivalenti cioè gli stati distinti dalla stringa vuota cioè quelle coppie di stati formate da uno stato accettante e da uno rigettante. Al passo successivo si procede esaminando tutte le coppie di stati che momentaneamente l'algoritmo considera equivalenti (che non ha marcato come distinti nei passi precedenti): se per un simbolo dell'alfabeto $s$ da quella coppia di stati di partenza si arriva a una coppia di stati distinti (già marcati dall'algoritmo nei passi precedenti) anche la coppia di stati di partenza va marcata come distinti perchè se gli stati di arrivo sono distinti vuol dire che esiste un suffisso $w$ che li distingue quindi gli stati di partenza saranno distinti dalla stringa $sw$. Questa procedura va ripetuta ed ha termine quando al passo corrente l'algoritmo non ha trovato nessuna nuova coppia di stati distinti.Inoltre come attesta il seguente teorema:
\begin{teorema*}
Se due stati non sono marcati come distinti dall'algoritmo di table-filling, allora questi stati sono equivalenti. \cite{Hop07}
\end{teorema*}
Identificati gli stati equivalenti è possibile passare alla minimizzazione tramite il merge degli stati.

Per testare l'equivalenza di due DFA si manda in esecuzione il \textit{table-filling} sul DFA costituito dall'unione dei due DFA di cui verificare l'equivalenza. Se al termine dell'esecuzione i due stati iniziali risultano equivalenti i due DFA di partenza saranno equivalenti perchè non esiste nessuna stringa che distingue i due stati iniziali e quindi i due linguaggi dei due DFA sono identici. Per ottimizzare l'esecuzione è possibile interrompere l'esecuzione non appena viene individuato che i due stati iniziali sono distinti.

Per abilitare il \textit{teacher} a ritornare, in caso di inequivalenza, una \textit{witness} è necessario modificare leggermente il \textit{table-filling}. Anzichè limitarsi nel marcare le coppie di stati non equivalenti è necessario anche memorizzare il simbolo dell'alfabeto che ha causato l'inequivalenza. Inoltre bisogna marcare con la stringa vuota o con un marcatore speciale le coppie di stati distinti in fase d'inizializzazione . Quando l'algoritmo termina è possibile creare il controesempio, partendo dalla coppia di stati iniziali, percorrendo la struttura dati usata durante il \textit{table-filling} con l'ausilio delle funzioni di transizione dei due DFA e del marcatore memorizzato fino a quando non viene trovata una coppia di stati contrassegnata con la stringa vuota (cioè uno stato accettante e l'altro no). E' garantito che il controesempio venga sempre individuato ma non vi è la garanzia che ad essere scovato sia quello di lunghezza minima.
\subsubsection{Una versione più efficiente}
Il \textit{table-filling} ha una complessità polinomiale rispetto ad n cioè alla somma del numero degli stati dei DFA di cui si vuole testare l'equivalenza. Si avranno $n*\frac{n-1}{2}$  coppie distinte di stati che verranno tutte considerate ad ogni visita della tabella (la struttura dati mantenuta dall'algoritmo) quindi $\mathcal{O}(n^{2})$. Nel caso peggiore una sola coppia verrà scoperta essere distinta e le coppie sono tutte distinte quindi la tabella verrà esaminata al più $\mathcal{O}(n^{2})$ volte. Moltiplicando le due complessità si ottiene $\mathcal{O}(n^{4})$ che è il costo computazionale nel caso peggiore.

E' possibile migliorare la complessità computazionale a $\mathcal{O}(n^{2})$ memorizzando per ogni coppia di stati $(i,j)$ una lista di dipendenza costituita da tutte quelle coppie (x,y) che tramite un singolo simbolo dell'alfabeto $k$ arrivano in $(i,j)$ cioè $\hat{\delta}(x,k)=i$ e $\hat{\delta}(y,k)=j$ .
Si memorizzano in una coda tutte le coppie di stati inizialmente distinte. Si estrae una coppia dalla coda (che quindi è distinta) e tutte le coppie che da essa dipendono sono marcate come distinte nella tabella e sono aggiunte in fondo alla coda. L'algoritmo ripete questi passi finchè la coda è vuota.